from bnetbase import Variable, Factor, BN
import csv
import copy

def multiply_factors(Factors):
    '''Factors is a list of factor objects.
    Return a new factor that is the product of the factors in Factors.
    @return a factor''' 
    ### YOUR CODE HERE ###

    # Init scope
    scope = []
    seen_names = []
    new_name = ''
    for f in Factors:
        for var in f.get_scope():
            if var.name not in seen_names:
                scope.append(var)
                seen_names.append(var.name)
        new_name += f"({f.name})"
    # Init new factor
    new_factor = Factor(new_name, scope)
    
    all_possibilities = construct_all_possibilities(scope)

    all_assignments = []
    # for each combination, crank up its corresponding value to assign
    for pos in all_possibilities:  # pos is a list of assignments ordered w.r.t scope
        prob_multiplier = 1
        for f in Factors:
            f_scope = f.get_scope()

            # search for the variables in f_scope that's also in total scope
            values_to_query = []
            for var in f_scope:
                for i in range(len(scope)):
                    var2 = scope[i]
                    if var.name == var2.name:
                        values_to_query.append(pos[i])
            
            p = f.get_value(values_to_query)
            prob_multiplier = prob_multiplier * p

        pos_and_val = pos + [prob_multiplier] 
        all_assignments.append(pos_and_val)

    # add in the values
    new_factor.add_values(all_assignments)
    return new_factor




def construct_all_possibilities(scope):
    """
    Construct all possibilities of assignments based on scope
    """
    l = []
    for var in scope:
        sub_l = []
        for value in var.domain():
            sub_l.append(value)
        l.append(sub_l)
    all_possibilities = permut(l)
    return all_possibilities


def permut(l):
    """
    Return the permutations for l, a list of lists,
    as a list of lists

    """
    if len(l)==1:
        x = []
        for item in l[0]:
            x.append([item])
        return x

    else:   
        x = []
        for a in l[0]:
            for b in permut(l[1:]):
                x.append([a] + b)
        return x






def restrict_factor(f, var, value):
    '''f is a factor, var is a Variable, and value is a value from var.domain.
    Return a new factor that is the restriction of f by this var = value.
    Don't change f! If f has only one variable its restriction yields a
    constant factor.
    @return a factor''' 
    ### YOUR CODE HERE ###
    new_name = f.name + "'"
    new_scope = copy.deepcopy(f.get_scope())

    for i in range(len(new_scope)):
        v = new_scope[i]
        if var.name == v.name:  # if this is the variable to restrict
            break
    new_var = Variable(var.name, [value])
    new_scope[i] = new_var  # replace the original var with a new one
    new_factor = Factor(new_name, new_scope)  # init new factor

    # Construct all possibilities of assignments
    all_possibilities = construct_all_possibilities(new_scope)

    # for each possibility, query from the original factor
    total_assignment = []
    for pos in all_possibilities:
        val = f.get_value(pos)
        pos_and_val = pos + [val]
        total_assignment.append(pos_and_val)
    new_factor.add_values(total_assignment)
    return new_factor







def sum_out_variable(f, var):
    '''f is a factor, var is a Variable.
    Return a new factor that is the result of summing var out of f, by summing
    the function generated by the product over all values of var.
    @return a factor'''       
    ### YOUR CODE HERE ###

    # Sum out all like-terms
    new_scope = copy.deepcopy(f.get_scope())
    for i in range(len(new_scope)):
        v = new_scope[i]
        if v.name == var.name:
            break
    new_scope.remove(v)

    # construct all possibilities of assignments
    all_possibilities = construct_all_possibilities(new_scope)
    total_assignment = []
    for pos in all_possibilities:
        # Search all the variables in f that satisfy pos & sum them together
        sum = 0
        for var_assignment in var.domain():
            x = pos[:i] + [var_assignment] + pos[i:]  # recall we extracted var from index i
            val = f.get_value(x)
            sum += val
        pos_and_val = pos + [sum]
        total_assignment.append(pos_and_val)
    
    new_name = f.name + f" ({var.name} summed-out)"
    new_factor = Factor(new_name, new_scope)
    new_factor.add_values(total_assignment)
    return new_factor





def normalize(nums):
    '''num is a list of numbers. Return a new list of numbers where the new
    numbers sum to 1, i.e., normalize the input numbers.
    @return a normalized list of numbers'''
    ### YOUR CODE HERE ###
    sum = 0
    for n in nums:
        sum += n
    
    new_lst = []
    for n in nums:
        new_lst.append(n / sum)
    return new_lst



# OMITTED!!! ################################################################
def min_fill_ordering(Factors, QueryVar):
    '''Factors is a list of factor objects, QueryVar is a query variable.
    Compute an elimination order given list of factors using the min fill heuristic. 
    Variables in the list will be derived from the scopes of the factors in Factors. 
    Order the list such that the first variable in the list generates the smallest
    factor upon elimination. The QueryVar must NOT part of the returned ordering list.
    @return a list of variables''' 
    ### YOUR CODE HERE ###
    list_variables = []
    seen_names = []
    for f in Factors:
        for v in f.get_scope():
            if v.name != QueryVar.name and v.name not in seen_names:
                list_variables.append(v)
                seen_names.append(v.name)

    # sort the list in ascending order
    list_variables.sort(key=lambda x: rank_size(x, Factors))
    return list_variables


def rank_size(variable: Variable, Factors: list[Factor]):
    """
    Return the size of the resulting factor after eliminating variable
    from the Factors list
    """
    # Search over factors to find all factors containing variable
    found = []
    for f in Factors:
        for item in f.get_scope():
            if item.name == variable.name:
                found.append(f)
                break
    new_factor = multiply_factors(found)
    new_factor = sum_out_variable(new_factor, variable)
    return len(new_factor.get_scope())
            
#######################################################################






def VE(Net, QueryVar, EvidenceVars):
    
    """
    Input: Net---a BN object (a Bayes Net)
           QueryVar---a Variable object (the variable whose distribution
                      we want to compute)
           EvidenceVars---a LIST of Variable objects. Each of these
                          variables has had its evidence set to a particular
                          value from its domain using set_evidence.
     VE returns a distribution over the values of QueryVar, i.e., a list
     of numbers, one for every value in QueryVar's domain. These numbers
     sum to one, and the i'th number is the probability that QueryVar is
     equal to its i'th value given the setting of the evidence
     variables. For example if QueryVar = A with Dom[A] = ['a', 'b',
     'c'], EvidenceVars = [B, C], and we have previously called
     B.set_evidence(1) and C.set_evidence('c'), then VE would return a
     list of three numbers. E.g. [0.5, 0.24, 0.26]. These numbers would
     mean that Pr(A='a'|B=1, C='c') = 0.5 Pr(A='a'|B=1, C='c') = 0.24
     Pr(A='a'|B=1, C='c') = 0.26
     @return a list of probabilities, one for each item in the domain of the QueryVar
     """
    ### YOUR CODE HERE ###
    ############################## Restricting Evidence ##########################
    remaining_factors = Net.factors()

    # Restrict each evidence var to its observed value
    for evidence_var in EvidenceVars:
        evidence_value = evidence_var.get_evidence()

        # if factor contains evidence_var, restrict it
        for i in range(len(remaining_factors)):
            f = remaining_factors[i]
            is_evidence_factor = False
            for scope_v in f.get_scope():
                if scope_v.name == evidence_var.name:
                    is_evidence_factor = True
                    break
            if is_evidence_factor: # if f is an evidence factor
                new_factor = restrict_factor(f, evidence_var, evidence_value)
                remaining_factors[i] = new_factor  # substitute the old one with the new restricted factor
                
    # for f in remaining_factors:
    #     print(f"remaining: {f.name}")

    ############################## Eliminating Hidden Vars ##########################
    # Eliminate the hidden variables (ones that aren't query AND not evidence)
    hidden_vars = []
    for var in Net.variables():
        hidden = True  # first assume it's hidden
        if var.name == QueryVar.name:
            hidden = False

        for evidence_var in EvidenceVars:
            if var.name == evidence_var.name:
                hidden = False
                break
        if hidden:
            hidden_vars.append(var)
    
    # For each hidden var, eliminate it
    while len(hidden_vars) > 0:
        v = hidden_vars.pop()
        factors_containing_v = []
        for f in remaining_factors:
            for scope_v in f.get_scope():
                if v.name == scope_v.name:
                    factors_containing_v.append(f)
                    break
        # Delete the factors that will be used here, from now on they forge into a new factor
        for f in factors_containing_v:
            remaining_factors.remove(f)

        new_factor = multiply_factors(factors_containing_v)  # Multiply all factors containing v together
        new_factor = sum_out_variable(new_factor, v)  # Sum out w.r.t. v
        remaining_factors.append(new_factor)

    ###################### Multiply Remaining Factors Altogether  #####################
    result_factor = multiply_factors(remaining_factors)
    result_factor.print_table()  # debugging
    
    # Assign the evidence vars with their values in result factor
    for evidence_var in EvidenceVars:
        evidence_value = evidence_var.get_evidence()
        for v in result_factor.get_scope():
            if evidence_var.name == v.name:
                v.set_assignment(evidence_value)

    # search for the query var in the result factor
    prob_list = []
    for v in result_factor.get_scope():
        if v.name == QueryVar.name:
            for value in QueryVar.domain():  # For every value given in the order of QueryVar's domain
                v.set_assignment(value)
                p = result_factor.get_value_at_current_assignments()
                prob_list.append(p)
            break
    return normalize(prob_list)


    
def quick_init():
    """
    Quick initialization of objects for debugging in
    the terminal
    """
    v1 = Variable('v1', domain=[1,2,3])
    v2 = Variable('v2', domain=[2,3])
    v3 = Variable('v3', domain=[4,5,6])

    f1 = Factor('f1', [v1,v2])
    f1.add_values([[1,3,0.5],[3,3,0.8]])

    f2 = Factor('f2', [v2,v3])
    f2.add_values([[3,5,0.4],[2,4,0.1],[3,6,0.2]])

    bn = BN('bn', [v1,v2,v3], [f1,f2])

    return bn, f1, f2, v1, v2, v3



    
            




        
        


def NaiveBayesModel():
    '''
   NaiveBayesModel returns a BN that is a Naive Bayes model that 
   represents the joint distribution of value assignments to 
   variables in the Adult Dataset from UCI.  Remember a Naive Bayes model
   assumes P(X1, X2,.... XN, Class) can be represented as 
   P(X1|Class)*P(X2|Class)* .... *P(XN|Class)*P(Class).
   When you generated your Bayes Net, assume that the values 
   in the SALARY column of the dataset are the CLASS that we want to predict.
   @return a BN that is a Naive Bayes model and which represents the Adult Dataset. 
    '''
    ### READ IN THE DATA
    input_data = []
    with open('data/adult-train.csv', newline='') as csvfile:
        reader = csv.reader(csvfile)
        headers = next(reader, None) #skip header row
        for row in reader:
            input_data.append(row)

    ### DOMAIN INFORMATION REFLECTS ORDER OF COLUMNS IN THE DATA SET
    variable_domains = {
    "Work": ['Not Working', 'Government', 'Private', 'Self-emp'],
    "Education": ['<Gr12', 'HS-Graduate', 'Associate', 'Professional', 'Bachelors', 'Masters', 'Doctorate'],    
    "Occupation": ['Admin', 'Military', 'Manual Labour', 'Office Labour', 'Service', 'Professional'],    
    "MaritalStatus": ['Not-Married', 'Married', 'Separated', 'Widowed'],
    "Relationship": ['Wife', 'Own-child', 'Husband', 'Not-in-family', 'Other-relative', 'Unmarried'],
    "Race": ['White', 'Black', 'Asian-Pac-Islander', 'Amer-Indian-Eskimo', 'Other'],
    "Gender": ['Male', 'Female'],
    "Country": ['North-America', 'South-America', 'Europe', 'Asia', 'Middle-East', 'Carribean'],
    "Salary": ['<50K', '>=50K']
    }
    ### YOUR CODE HERE ###
    # print(input_data)
    # input_data is a list of lists, each list has 9 values for our 9 attributes, in the order:
    # work, education, martial-status, occupation, relationship, race, gender, country, salary

    # Create all variables:
    work = Variable('work', domain=variable_domains['Work'])
    edu = Variable('education', variable_domains['Education'])
    ms = Variable('martial status', variable_domains['MaritalStatus'])
    job = Variable('occupation', variable_domains['Occupation'])
    relationship = Variable('relationship', variable_domains['Relationship'])
    race = Variable('race', variable_domains['Race'])
    gender = Variable('gender', variable_domains['Gender'])
    country = Variable('country', variable_domains['Country'])
    salary = Variable('salary', variable_domains['Salary'])

    # Create all factors with salary being the priori
    work_f = Factor('f1', [work, salary])
    edu_f = Factor('f2', [edu, salary])
    ms_f = Factor('f3', [ms, salary])
    job_f = Factor('f4', [job, salary])
    relationship_f = Factor('f5', [relationship, salary])
    race_f = Factor('f6', [race, salary])
    gender_f = Factor('f7', [gender, salary])
    country_f = Factor('f8', [country, salary])
    salary_f = Factor('f9', [salary])

    conditional_factors = [work_f, edu_f, ms_f, job_f, relationship_f, race_f, gender_f, country_f]
    # conditional_factors is an ordered list of all factors conditioned on salary
    # Compute the conditional probabilities Pr(x|salary) for each x
    for i in range(8):
        f = conditional_factors[i]
        values_f = []  # all values to assign to f
        all_pos = construct_all_possibilities(f.get_scope())  # all permuattions of f's variables
        for pos in all_pos:  # each possibility is a list of 2 items: [x's value, salary's value]
            x_val = pos[0]
            salary_val = pos[1]
            numerator = 0 # num of people with x = x_val and salary = salary_val
            denominator = 0  # num of people with salary = salary_val
            for person in input_data:
                x = person[i]
                s = person[8]
                if s == salary_val:
                    denominator += 1
                    if x == x_val:
                        numerator += 1
            p = numerator / denominator
            pos.append(p)
            values_f.append(pos)
        f.add_values(values_f)
        # f.print_table()
    
    # don't forget to compute P(salary)
    total_people = len(input_data)
    above_count = 0
    below_count = 0
    for person in input_data:
        if person[8] == variable_domains['Salary'][0]:  # below
            below_count += 1
        else:
            above_count += 1
    p_above = above_count / total_people
    p_below = below_count / total_people
    salary_f.add_values([[variable_domains['Salary'][0], p_below], [variable_domains['Salary'][1], p_above]])
    # salary_f.print_table()

    variables = [work, edu, ms, job, relationship, race, gender, country, salary]
    factors = [work_f, edu_f, ms_f, job_f, relationship_f, race_f, gender_f, country_f, salary_f]
    bn = BN('naive bayes', variables, factors)

    return bn




def Explore(Net, question):
    '''    Input: Net---a BN object (a Bayes Net)
           question---an integer indicating the question in HW4 to be calculated. Options are:
           1. What percentage of the women in the data set end up with a P(S=">=$50K"|E1) that is strictly greater than P(S=">=$50K"|E2)?
           2. What percentage of the men in the data set end up with a P(S=">=$50K"|E1) that is strictly greater than P(S=">=$50K"|E2)?
           3. What percentage of the women in the data set with P(S=">=$50K"|E1) > 0.5 actually have a salary over $50K?
           4. What percentage of the men in the data set with P(S=">=$50K"|E1) > 0.5 actually have a salary over $50K?
           5. What percentage of the women in the data set are assigned a P(Salary=">=$50K"|E1) > 0.5, overall?
           6. What percentage of the men in the data set are assigned a P(Salary=">=$50K"|E1) > 0.5, overall?
           @return a percentage (between 0 and 100)
    ''' 
    ### YOUR CODE HERE ###

    # Read in test data set #############################################
    input_data = []
    with open('data/adult-test.csv', newline='') as csvfile:
        reader = csv.reader(csvfile)
        headers = next(reader, None) #skip header row
        for row in reader:
            input_data.append(row)

    # Create core evidence sets ########################################
    work = Net.get_variable('work') # variables in Net have the same name as we give them in NaiveBayesModel()
    occupation = Net.get_variable('occupation') 
    education = Net.get_variable('education')
    relationship = Net.get_variable('relationship')
    E1 = [work, occupation, education, relationship]

    gender = Net.get_variable('gender')
    E2 = [work, occupation, education, relationship, gender]

    salary = Net.get_variable('salary')

    # Begin answering questions ##########################################
    if question == 1:
        numerator = 0
        denominator = 0
        for person in input_data: # for every person in the input data
            if person[6] == 'Female':  # if woman
                denominator += 1
                # set the evidence
                person_work = person[0]
                person_occupation = person[3]
                person_education = person[1]
                person_relationship = person[4]

                # Predict using E1 as the only evidence we gathered
                work.set_evidence(person_work)
                occupation.set_evidence(person_occupation)
                education.set_evidence(person_education)
                relationship.set_evidence(person_relationship)
                p1 = VE(Net, salary, E1)[1]  # Pick the case `salary >= 50K', which is the second case in salary's domain

                # Predict using the extended evidence set E2
                gender.set_evidence('Female')
                p2 = VE(Net, salary, E2)[1]

                print(f"p1: {p1}, p2: {p2}")
                if p1 > p2:
                    numerator += 1
        return (numerator / denominator) * 100  # Return a percentage
    
    elif question == 2:
        numerator = 0
        denominator = 0
        for person in input_data:
            if person[6] == 'Male':
                denominator += 1
                # set the evidence
                person_work = person[0]
                person_occupation = person[3]
                person_education = person[1]
                person_relationship = person[4]

                # Predict using E1 as the only evidence we gathered
                work.set_evidence(person_work)
                occupation.set_evidence(person_occupation)
                education.set_evidence(person_education)
                relationship.set_evidence(person_relationship)
                p1 = VE(Net, salary, E1)[1]

                # Predict using the extended evidence set E2
                gender.set_evidence('Male')
                p2 = VE(Net, salary, E2)[1]

                if p1 > p2:
                    numerator += 1
        return (numerator / denominator) * 100
    
    elif question == 3:
        numerator = 0
        denominator = 0
        for person in input_data: # for every person in the input data
            if person[6] == 'Female':  # if woman
                # set the evidence
                person_work = person[0]
                person_occupation = person[3]
                person_education = person[1]
                person_relationship = person[4]

                # Predict using E1 as the only evidence we gathered
                work.set_evidence(person_work)
                occupation.set_evidence(person_occupation)
                education.set_evidence(person_education)
                relationship.set_evidence(person_relationship)
                p1 = VE(Net, salary, E1)[1]  # Pick the case `salary >= 50K', which is the second case in salary's domain

                if p1 > 0.5:
                    denominator += 1
                    # next check the actual salary (see if it's >= 50K)
                    s = person[8]
                    if s == '>=50K':
                        numerator += 1
        return (numerator / denominator) * 100
    
    elif question == 4:
        numerator = 0
        denominator = 0
        for person in input_data: # for every person in the input data
            if person[6] == 'Male':  # if man
                # set the evidence
                person_work = person[0]
                person_occupation = person[3]
                person_education = person[1]
                person_relationship = person[4]

                # Predict using E1 as the only evidence we gathered
                work.set_evidence(person_work)
                occupation.set_evidence(person_occupation)
                education.set_evidence(person_education)
                relationship.set_evidence(person_relationship)
                p1 = VE(Net, salary, E1)[1]  # Pick the case `salary >= 50K', which is the second case in salary's domain

                if p1 > 0.5:
                    denominator += 1
                    # next check the actual salary (see if it's >= 50K)
                    s = person[8]
                    if s == '>=50K':
                        numerator += 1
        return (numerator / denominator) * 100
    
    elif question == 5:
        numerator = 0
        denominator = 0
        for person in input_data: # for every person in the input data
            if person[6] == 'Female':  # if woman
                denominator += 1
                # set the evidence
                person_work = person[0]
                person_occupation = person[3]
                person_education = person[1]
                person_relationship = person[4]

                # Predict using E1 as the only evidence we gathered
                work.set_evidence(person_work)
                occupation.set_evidence(person_occupation)
                education.set_evidence(person_education)
                relationship.set_evidence(person_relationship)
                p1 = VE(Net, salary, E1)[1]  # Pick the case `salary >= 50K', which is the second case in salary's domain

                if p1 > 0.5:
                    numerator += 1
        return (numerator / denominator) * 100
    
    elif question == 6:
        numerator = 0
        denominator = 0
        for person in input_data: # for every person in the input data
            if person[6] == 'Male':  # if man
                denominator += 1
                # set the evidence
                person_work = person[0]
                person_occupation = person[3]
                person_education = person[1]
                person_relationship = person[4]

                # Predict using E1 as the only evidence we gathered
                work.set_evidence(person_work)
                occupation.set_evidence(person_occupation)
                education.set_evidence(person_education)
                relationship.set_evidence(person_relationship)
                p1 = VE(Net, salary, E1)[1]  # Pick the case `salary >= 50K', which is the second case in salary's domain

                if p1 > 0.5:
                    numerator += 1
        return (numerator / denominator) * 100

    






